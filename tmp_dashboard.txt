app.get('/api/dashboard', async (req, res) => {
  // 現在のUSDJPYレート（キャッシュ利用）を取得。失敗時は1でフォールバック
  let usdJpyRate = 1;
  try {
    const fx = await fetchWithCache(fxKey('USDJPY'), CACHE_TTL.fx, () => fxProvider.getRate('USDJPY'));
    usdJpyRate = Number(fx.price) || 1;
  } catch (e) {
    console.warn('FX fetch failed for dashboard; using 1 as fallback:', e.message);
  }

  const queries = {
    totalAssets: `SELECT COUNT(*) as count FROM assets`,
    totalValue: `
      SELECT SUM(COALESCE(v.value_jpy, a.book_value_jpy)) as total 
      FROM assets a
      LEFT JOIN (
        SELECT vv.asset_id, vv.value_jpy
        FROM valuations vv
        INNER JOIN (
          SELECT asset_id, MAX(as_of) AS max_as_of
          FROM valuations
          GROUP BY asset_id
        ) last ON last.asset_id = vv.asset_id AND vv.as_of = last.max_as_of
      ) v ON a.id = v.asset_id
    `,
    assetsByClass: `
      SELECT a.class, COUNT(*) as count, SUM(COALESCE(v.value_jpy, a.book_value_jpy)) as total_value 
      FROM assets a
      LEFT JOIN (
        SELECT vv.asset_id, vv.value_jpy
        FROM valuations vv
        INNER JOIN (
          SELECT asset_id, MAX(as_of) AS max_as_of
          FROM valuations
          GROUP BY asset_id
        ) last ON last.asset_id = vv.asset_id AND vv.as_of = last.max_as_of
      ) v ON a.id = v.asset_id
      GROUP BY a.class
    `,
    topAssets: `
      SELECT a.name, a.note, a.book_value_jpy, COALESCE(v.value_jpy, a.book_value_jpy) as current_value_jpy
      FROM assets a
      LEFT JOIN (
        SELECT vv.asset_id, vv.value_jpy
        FROM valuations vv
        INNER JOIN (
          SELECT asset_id, MAX(as_of) AS max_as_of
          FROM valuations
          GROUP BY asset_id
        ) last ON last.asset_id = vv.asset_id AND vv.as_of = last.max_as_of
      ) v ON a.id = v.asset_id
      ORDER BY COALESCE(v.value_jpy, a.book_value_jpy) DESC 
      LIMIT 3
    `,
    monthlyTrend: `
      SELECT 
        strftime('%Y-%m', a.created_at) as month,
        SUM(
          CASE 
            WHEN a.class='us_stock' THEN COALESCE(us.avg_price_usd,0)*COALESCE(us.quantity,0)*?
            WHEN a.class='jp_stock' THEN COALESCE(jp.avg_price_jpy,0)*COALESCE(jp.quantity,0)
            WHEN a.class='precious_metal' THEN COALESCE(pm.unit_price_jpy,0)*COALESCE(pm.weight_g,0)
            ELSE a.book_value_jpy
          END
        ) as book_value_total,
        SUM(
          COALESCE(v.value_jpy,
            CASE 
              WHEN a.class='us_stock' THEN COALESCE(us.avg_price_usd,0)*COALESCE(us.quantity,0)*?
              WHEN a.class='jp_stock' THEN COALESCE(jp.avg_price_jpy,0)*COALESCE(jp.quantity,0)
              WHEN a.class='precious_metal' THEN COALESCE(pm.unit_price_jpy,0)*COALESCE(pm.weight_g,0)
              ELSE a.book_value_jpy
            END
          )
        ) as market_value_total
      FROM assets a
      LEFT JOIN us_stocks us ON us.asset_id = a.id
      LEFT JOIN jp_stocks jp ON jp.asset_id = a.id
      LEFT JOIN precious_metals pm ON pm.asset_id = a.id
      LEFT JOIN (
        SELECT vv.asset_id, vv.value_jpy
        FROM valuations vv
        INNER JOIN (
          SELECT asset_id, MAX(as_of) AS max_as_of
          FROM valuations
          GROUP BY asset_id
        ) last ON last.asset_id = vv.asset_id AND vv.as_of = last.max_as_of
      ) v ON a.id = v.asset_id
      WHERE a.created_at IS NOT NULL 
      GROUP BY strftime('%Y-%m', a.created_at)
      ORDER BY month DESC 
      LIMIT 12
    `
  };
  
  const results = {};
  let completed = 0;
  const total = Object.keys(queries).length;
  
  Object.entries(queries).forEach(([key, query]) => {
    const params = key === 'monthlyTrend' ? [usdJpyRate, usdJpyRate] : [];
    db.all(query, params, (err, rows) => {
      if (!err) {
        results[key] = rows;
      }
      completed++;
      
      if (completed === total) {
        res.json(results);
      }
    });
  });
});

// Dashboard class summary route - book value vs market value comparison by asset class
app.get('/api/dashboard/class-summary', async (req, res) => {
  // 現在のUSDJPYレート（キャッシュ利用）
  let usdJpyRate = 1;
  try {
    const fx = await fetchWithCache(fxKey('USDJPY'), CACHE_TTL.fx, () => fxProvider.getRate('USDJPY'));
    usdJpyRate = Number(fx.price) || 1;
  } catch (e) {
    console.warn('FX fetch failed for class-summary; using 1 as fallback:', e.message);
  }

  const query = `
    SELECT
      a.class AS class,
      SUM(
        CASE 
          WHEN a.class='us_stock' THEN COALESCE(us.avg_price_usd,0)*COALESCE(us.quantity,0)*?
          WHEN a.class='jp_stock' THEN COALESCE(jp.avg_price_jpy,0)*COALESCE(jp.quantity,0)
          WHEN a.class='precious_metal' THEN COALESCE(pm.unit_price_jpy,0)*COALESCE(pm.weight_g,0)
          ELSE a.book_value_jpy
        END
      ) AS book_total_jpy,
      SUM(
        COALESCE(
          (SELECT v.value_jpy
           FROM valuations v
           WHERE v.asset_id = a.id
           ORDER BY v.as_of DESC, v.id DESC
           LIMIT 1),
          CASE 
            WHEN a.class='us_stock' THEN COALESCE(us.avg_price_usd,0)*COALESCE(us.quantity,0)*?
            WHEN a.class='jp_stock' THEN COALESCE(jp.avg_price_jpy,0)*COALESCE(jp.quantity,0)
            WHEN a.class='precious_metal' THEN COALESCE(pm.unit_price_jpy,0)*COALESCE(pm.weight_g,0)
            ELSE a.book_value_jpy
          END
        )
      ) AS market_total_jpy,
app.get('/api/dashboard/class-summary', async (req, res) => {
  // 現在のUSDJPYレート（キャッシュ利用）
  let usdJpyRate = 1;
  try {
    const fx = await fetchWithCache(fxKey('USDJPY'), CACHE_TTL.fx, () => fxProvider.getRate('USDJPY'));
    usdJpyRate = Number(fx.price) || 1;
  } catch (e) {
    console.warn('FX fetch failed for class-summary; using 1 as fallback:', e.message);
  }

  const query = `
    SELECT
      a.class AS class,
      SUM(
        CASE 
          WHEN a.class='us_stock' THEN COALESCE(us.avg_price_usd,0)*COALESCE(us.quantity,0)*?
          WHEN a.class='jp_stock' THEN COALESCE(jp.avg_price_jpy,0)*COALESCE(jp.quantity,0)
          WHEN a.class='precious_metal' THEN COALESCE(pm.unit_price_jpy,0)*COALESCE(pm.weight_g,0)
          ELSE a.book_value_jpy
        END
      ) AS book_total_jpy,
      SUM(
        COALESCE(
          (SELECT v.value_jpy
           FROM valuations v
           WHERE v.asset_id = a.id
           ORDER BY v.as_of DESC, v.id DESC
           LIMIT 1),
          CASE 
            WHEN a.class='us_stock' THEN COALESCE(us.avg_price_usd,0)*COALESCE(us.quantity,0)*?
            WHEN a.class='jp_stock' THEN COALESCE(jp.avg_price_jpy,0)*COALESCE(jp.quantity,0)
            WHEN a.class='precious_metal' THEN COALESCE(pm.unit_price_jpy,0)*COALESCE(pm.weight_g,0)
            ELSE a.book_value_jpy
          END
        )
      ) AS market_total_jpy,
      COUNT(*) AS count_assets
    FROM assets a
    LEFT JOIN us_stocks us ON us.asset_id = a.id
    LEFT JOIN jp_stocks jp ON jp.asset_id = a.id
    LEFT JOIN precious_metals pm ON pm.asset_id = a.id
    GROUP BY a.class
    ORDER BY book_total_jpy DESC
  `;

  db.all(query, [usdJpyRate, usdJpyRate], (err, rows) => {
    if (err) {
      console.error('Class summary query error:', err);
      return res.status(500).json({ error: 'データベースクエリエラー' });
    }

    const response = {
      as_of: new Date().toISOString(),
      items: rows.map(row => ({
        class: row.class,
        book_total_jpy: Math.round(row.book_total_jpy || 0),
        market_total_jpy: Math.round(row.market_total_jpy || 0),
        count: row.count_assets || 0
      }))
    };

    res.json(response);
  });
});

// User management routes (admin only)
app.get('/api/users', requireAdmin, (req, res) => {
  db.all('SELECT id, username, role, created_at FROM users ORDER BY created_at DESC', (err, rows) => {
    if (err) {
      return res.status(500).json({ error: err.message });
    }
    res.json(rows);
  });
});

app.post('/api/users', requireAdmin, (req, res) => {
  const { username, password, role } = req.body;
  
  if (!username || !password || !role) {
    return res.status(400).json({ error: 'Username, password, and role are required' });
  }
  
  if (!['admin', 'viewer'].includes(role)) {
    return res.status(400).json({ error: 'Invalid role' });
  }
  
  // Check if username already exists
  db.get('SELECT id FROM users WHERE username = ?', [username], (err, existingUser) => {
    if (err) {
      return res.status(500).json({ error: err.message });
    }
    
    if (existingUser) {
      return res.status(409).json({ error: 'Username already exists' });
    }
    
    // Hash password and create user
    bcrypt.hash(password, 10, (err, hash) => {
      if (err) {
        return res.status(500).json({ error: 'Password hashing failed' });
      }
      
      db.run('INSERT INTO users (username, password_hash, role) VALUES (?, ?, ?)',
        [username, hash, role],
        function(err) {
          if (err) {
            return res.status(500).json({ error: err.message });
          }
          
          const newUser = {
            id: this.lastID,
            username,
            role,
            created_at: new Date().toISOString()
          };
          
          logAudit('users', this.lastID, 'CREATE', null, newUser, req.session.user.id);
          res.status(201).json(newUser);
        }
      );
    });
  });
});

app.patch('/api/users/:id', requireAdmin, (req, res) => {
  const userId = req.params.id;
  const { username, role } = req.body;
  
  // Prevent admin from editing their own role
  if (parseInt(userId) === req.session.user.id && role !== undefined) {
    return res.status(400).json({ error: 'Cannot change your own role' });
  }
  
  // Get current user data for audit
  db.get('SELECT * FROM users WHERE id = ?', [userId], (err, currentUser) => {
    if (err || !currentUser) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    const updates = {};
    if (username && username !== currentUser.username) {
      // Check if new username is unique
      db.get('SELECT id FROM users WHERE username = ? AND id != ?', [username, userId], (err, existing) => {
        if (err) {
          return res.status(500).json({ error: err.message });
        }
        if (existing) {
          return res.status(409).json({ error: 'Username already exists' });
        }
        
        updates.username = username;
