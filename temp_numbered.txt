   1: /**
   2:  * BDD Tests for Duplicate Asset Detection and Integration
   3:  * Following BDD specifications from docs/BDD.md
   4:  */
   5: 
   6: const request = require('supertest');
   7: const fs = require('fs');
   8: const path = require('path');
   9: const sqlite3 = require('sqlite3').verbose();
  10: 
  11: // Import the app and services
  12: const app = require('../server');
  13: const DuplicateDetectionService = require('../server/duplicates/service');
  14: 
  15: describe('驥崎､・ョ繝ｼ繧ｿ邨ｱ蜷域ｩ溯・', () => {
  16:   let db;
  17:   let duplicateService;
  18:   let authCookie;
  19: 
  20:   beforeAll(async () => {
  21:     // Setup test database
  22:     const testDbPath = path.join(__dirname, 'test_portfolio.db');
  23:     if (fs.existsSync(testDbPath)) {
  24:       fs.unlinkSync(testDbPath);
  25:     }
  26:     
  27:     db = new sqlite3.Database(testDbPath);
  28:     duplicateService = new DuplicateDetectionService(db);
  29: 
  30:     // Initialize test schema
  31:     await initTestSchema();
  32:     
  33:     // Login as admin to get session cookie
  34:     const loginResponse = await request(app)
  35:       .post('/api/login')
  36:       .send({
  37:         username: 'admin',
  38:         password: 'admin123'
  39:       });
  40:     
  41:     authCookie = loginResponse.headers['set-cookie'];
  42:   });
  43: 
  44:   afterAll(() => {
  45:     if (db) {
  46:       db.close();
  47:     }
  48:     const testDbPath = path.join(__dirname, 'test_portfolio.db');
  49:     if (fs.existsSync(testDbPath)) {
  50:       fs.unlinkSync(testDbPath);
  51:     }
  52:   });
  53: 
  54:   beforeEach(async () => {
  55:     // Clear test data before each test
  56:     await clearTestData();
  57:   });
  58: 
  59:   async function initTestSchema() {
  60:     return new Promise((resolve) => {
  61:       db.serialize(() => {
  62:         // Create assets table
  63:         db.run(`CREATE TABLE IF NOT EXISTS assets (
  64:           id INTEGER PRIMARY KEY AUTOINCREMENT,
  65:           class TEXT NOT NULL,
  66:           name TEXT NOT NULL,
  67:           note TEXT NOT NULL DEFAULT "",
  68:           acquired_at TEXT,
  69:           book_value_jpy INTEGER NOT NULL,
  70:           valuation_source TEXT NOT NULL DEFAULT 'manual',
  71:           liquidity_tier TEXT NOT NULL,
  72:           tags TEXT,
  73:           created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  74:           updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
  75:         )`);
  76: 
  77:         // Create class-specific tables
  78:         db.run(`CREATE TABLE IF NOT EXISTS us_stocks (
  79:           asset_id INTEGER PRIMARY KEY,
  80:           ticker TEXT NOT NULL,
  81:           exchange TEXT,
  82:           quantity REAL NOT NULL,
  83:           avg_price_usd REAL NOT NULL,
  84:           FOREIGN KEY(asset_id) REFERENCES assets(id) ON DELETE CASCADE
  85:         )`);
  86: 
  87:         db.run(`CREATE TABLE IF NOT EXISTS jp_stocks (
  88:           asset_id INTEGER PRIMARY KEY,
  89:           code TEXT NOT NULL,
  90:           quantity REAL NOT NULL,
  91:           avg_price_jpy REAL NOT NULL,
  92:           FOREIGN KEY(asset_id) REFERENCES assets(id) ON DELETE CASCADE
  93:         )`);
  94: 
  95:         db.run(`CREATE TABLE IF NOT EXISTS precious_metals (
  96:           asset_id INTEGER PRIMARY KEY,
  97:           metal TEXT NOT NULL,
  98:           weight_g REAL NOT NULL,
  99:           purity REAL,
 100:           unit_price_jpy REAL,
 101:           FOREIGN KEY(asset_id) REFERENCES assets(id) ON DELETE CASCADE
 102:         )`);
 103: 
 104:         db.run(`CREATE TABLE IF NOT EXISTS audit_log (
 105:           id INTEGER PRIMARY KEY AUTOINCREMENT,
 106:           table_name TEXT NOT NULL,
 107:           record_id INTEGER,
 108:           action TEXT NOT NULL,
 109:           old_values TEXT,
 110:           new_values TEXT,
 111:           user_id TEXT,
 112:           source TEXT DEFAULT 'api',
 113:           created_at DATETIME DEFAULT CURRENT_TIMESTAMP
 114:         )`);
 115: 
 116:         resolve();
 117:       });
 118:     });
 119:   }
 120: 
 121:   async function clearTestData() {
 122:     return new Promise((resolve) => {
 123:       db.serialize(() => {
 124:         db.run('DELETE FROM us_stocks');
 125:         db.run('DELETE FROM jp_stocks');
 126:         db.run('DELETE FROM precious_metals');
 127:         db.run('DELETE FROM audit_log');
 128:         db.run('DELETE FROM assets', resolve);
 129:       });
 130:     });
 131:   }
 132: 
 133:   describe('Feature: 驥崎､・ｳ・肇縺ｮ讀懷・', () => {
 134:     describe('Scenario: 蜷御ｸ蜷咲ｧｰ縺ｮ驥崎､・ｳ・肇讀懷・', () => {
 135:       it('Given 隍・焚縺ｮ蜷御ｸ雉・肇繧ｨ繝ｳ繝医Μ縺悟ｭ伜惠縺吶ｋ When 驥崎､・､懷・蜃ｦ逅・ｒ螳溯｡後☆繧・Then 驥崎､・ｳ・肇縺檎音螳壹＆繧後ｋ', async () => {
 136:         // Given: Create duplicate assets with same class and name
 137:         const asset1 = await createTestAsset({
 138:           class: 'watch',
 139:           name: 'Rolex Submariner',
 140:           book_value_jpy: 1000000,
 141:           liquidity_tier: 'L3',
 142:           note: 'Black dial'
 143:         });
 144: 
 145:         const asset2 = await createTestAsset({
 146:           class: 'watch',
 147:           name: 'Rolex Submariner',
 148:           book_value_jpy: 1100000,
 149:           liquidity_tier: 'L3',
 150:           note: 'Green dial'
 151:         });
 152: 
 153:         // When: Execute duplicate detection
 154:         const duplicateGroups = await duplicateService.findDuplicates();
 155: 
 156:         // Then: Duplicates should be identified
 157:         expect(duplicateGroups.length).toBeGreaterThan(0);
 158:         
 159:         const nameMatchGroup = duplicateGroups.find(group => group.type === 'name_match');
 160:         expect(nameMatchGroup).toBeDefined();
 161:         expect(nameMatchGroup.assets).toHaveLength(2);
 162:         expect(nameMatchGroup.confidence).toBe(0.9);
 163:         
 164:         const assetIds = nameMatchGroup.assets.map(a => a.id);
 165:         expect(assetIds).toContain(asset1);
 166:         expect(assetIds).toContain(asset2);
 167:       });
 168:     });
 169: 
 170:     describe('Scenario: 譬ｪ蠑上ユ繧｣繝・き繝ｼ縺ｫ繧医ｋ驥崎､・､懷・', () => {
 171:       it('Given 蜷御ｸ繝・ぅ繝・き繝ｼ縺ｮ邀ｳ蝗ｽ譬ｪ縺瑚､・焚蟄伜惠縺吶ｋ When 驥崎､・､懷・蜃ｦ逅・ｒ螳溯｡後☆繧・Then 繝・ぅ繝・き繝ｼ驥崎､・′迚ｹ螳壹＆繧後ｋ', async () => {
 172:         // Given: Create duplicate US stocks with same ticker
 173:         const asset1 = await createTestAsset({
 174:           class: 'us_stock',
 175:           name: 'Apple Inc.',
 176:           book_value_jpy: 500000,
 177:           liquidity_tier: 'L1'
 178:         });
 179: 
 180:         const asset2 = await createTestAsset({
 181:           class: 'us_stock',
 182:           name: 'Apple Inc',
 183:           book_value_jpy: 600000,
 184:           liquidity_tier: 'L1'
 185:         });
 186: 
 187:         await createStockDetails(asset1, {
 188:           ticker: 'AAPL',
 189:           exchange: 'NASDAQ',
 190:           quantity: 10,
 191:           avg_price_usd: 150
 192:         });
 193: 
 194:         await createStockDetails(asset2, {
 195:           ticker: 'AAPL',
 196:           exchange: 'NASDAQ',
 197:           quantity: 15,
 198:           avg_price_usd: 160
 199:         });
 200: 
 201:         // When: Execute duplicate detection
 202:         const duplicateGroups = await duplicateService.findDuplicates();
 203: 
 204:         // Then: Ticker duplicates should be identified
 205:         const tickerGroup = duplicateGroups.find(group => group.type === 'us_stock_ticker');
 206:         expect(tickerGroup).toBeDefined();
 207:         expect(tickerGroup.assets).toHaveLength(2);
 208:         expect(tickerGroup.confidence).toBe(0.95);
 209:       });
 210:     });
 211: 
 212:     describe('Scenario: 雋ｴ驥大ｱ樣㍾驥上↓繧医ｋ鬘樔ｼｼ讀懷・', () => {
 213:       it('Given 蜷檎ｨｮ驥大ｱ槭〒鬘樔ｼｼ驥埼㍼縺ｮ雉・肇縺悟ｭ伜惠縺吶ｋ When 驥崎､・､懷・蜃ｦ逅・ｒ螳溯｡後☆繧・Then 鬘樔ｼｼ雉・肇縺檎音螳壹＆繧後ｋ', async () => {
 214:         // Given: Create similar precious metals
 215:         const asset1 = await createTestAsset({
 216:           class: 'precious_metal',
 217:           name: '邏秘≡繝舌・ 100g',
 218:           book_value_jpy: 800000,
 219:           liquidity_tier: 'L2'
 220:         });
 221: 
 222:         const asset2 = await createTestAsset({
 223:           class: 'precious_metal',
 224:           name: '驥大慍驥・102g',
 225:           book_value_jpy: 816000,
 226:           liquidity_tier: 'L2'
 227:         });
 228: 
 229:         await createPreciousMetalDetails(asset1, {
 230:           metal: 'gold',
 231:           weight_g: 100.0,
 232:           purity: 0.999,
 233:           unit_price_jpy: 8000
 234:         });
 235: 
 236:         await createPreciousMetalDetails(asset2, {
 237:           metal: 'gold',
 238:           weight_g: 102.0,
 239:           purity: 0.999,
 240:           unit_price_jpy: 8000
 241:         });
 242: 
 243:         // When: Execute duplicate detection
 244:         const duplicateGroups = await duplicateService.findDuplicates();
 245: 
 246:         // Then: Similar precious metals should be identified
 247:         const metalGroup = duplicateGroups.find(group => group.type === 'precious_metal_similar');
 248:         expect(metalGroup).toBeDefined();
 249:         expect(metalGroup.assets).toHaveLength(2);
 250:         expect(metalGroup.confidence).toBe(0.7);
 251:       });
 252:     });
 253:   });
 254: 
 255:   describe('Feature: 驥崎､・ョ繝ｼ繧ｿ縺ｮ邨ｱ蜷・, () => {
 256:     describe('Scenario: 驥崎､・ｳ・肇縺ｮ邨ｱ蜷亥・逅・, () => {
 257:       it('Given 驥崎､・ｳ・肇縺梧､懷・縺輔ｌ縺ｦ縺・ｋ When 邨ｱ蜷亥・逅・ｒ螳溯｡後☆繧・Then 繝・・繧ｿ縺檎ｵｱ蜷医＆繧後・㍾隍・′隗｣豸医＆繧後ｋ', async () => {
 258:         // Given: Create duplicate assets
 259:         const keepAssetId = await createTestAsset({
 260:           class: 'watch',
 261:           name: 'Omega Speedmaster',
 262:           book_value_jpy: 500000,
 263:           liquidity_tier: 'L3',
 264:           note: 'Professional model'
 265:         });
 266: 
 267:         const mergeAssetId = await createTestAsset({
 268:           class: 'watch',
 269:           name: 'Omega Speedmaster',
 270:           book_value_jpy: 520000,
 271:           liquidity_tier: 'L3',
 272:           note: 'Hesalite crystal'
 273:         });
 274: 
 275:         // When: Execute merge operation
 276:         const mergeResult = await duplicateService.mergeDuplicates(
 277:           [keepAssetId, mergeAssetId],
 278:           keepAssetId,
 279:           'test_user'
 280:         );
 281: 
 282:         // Then: Assets should be merged successfully
 283:         expect(mergeResult.success).toBe(true);
 284:         expect(mergeResult.kept_asset_id).toBe(keepAssetId);
 285:         expect(mergeResult.merged_asset_ids).toContain(mergeAssetId);
 286: 
 287:         // Verify the kept asset has combined notes
 288:         const keptAsset = await getAssetById(keepAssetId);
 289:         expect(keptAsset).toBeDefined();
 290:         expect(keptAsset.note).toContain('Professional model');
 291:         expect(keptAsset.note).toContain('Hesalite crystal');
 292: 
 293:         // Verify merged asset is deleted
 294:         const mergedAsset = await getAssetById(mergeAssetId);
 295:         expect(mergedAsset).toBeNull();
 296: 
 297:         // Verify audit log
 298:         const auditEntries = await getAuditLogEntries('MERGE_DUPLICATE');
 299:         expect(auditEntries).toHaveLength(1);
 300:         expect(auditEntries[0].record_id).toBe(mergeAssetId);
 301:       });
 302:     });
 303: 
 304:     describe('Scenario: 驥崎､・┌隕悶・險ｭ螳・, () => {
 305:       it('Given 驥崎､・ｳ・肇縺悟ｭ伜惠縺吶ｋ When 辟｡隕冶ｨｭ螳壹ｒ螳溯｡後☆繧・Then 莉雁ｾ後・驥崎､・､懷・蟇ｾ雎｡縺九ｉ髯､螟悶＆繧後ｋ', async () => {
 306:         // Given: Create assets that look like duplicates
 307:         const asset1 = await createTestAsset({
 308:           class: 'collection',
 309:           name: 'Pokemon Card Set',
 310:           book_value_jpy: 100000,
 311:           liquidity_tier: 'L4'
 312:         });
 313: 
 314:         const asset2 = await createTestAsset({
 315:           class: 'collection',
 316:           name: 'Pokemon Card Set',
 317:           book_value_jpy: 110000,
 318:           liquidity_tier: 'L4'
 319:         });
 320: 
 321:         // When: Mark as not duplicates
 322:         const ignoreResult = await duplicateService.markAsNotDuplicates(
 323:           [asset1, asset2],
 324:           'test_user'
 325:         );
 326: 
 327:         // Then: Should be marked as ignored
 328:         expect(ignoreResult.success).toBe(true);
 329:         expect(ignoreResult.ignored_assets).toContain(asset1);
 330:         expect(ignoreResult.ignored_assets).toContain(asset2);
 331: 
 332:         // Verify audit log entry
 333:         const auditEntries = await getAuditLogEntries('IGNORE_DUPLICATES');
 334:         expect(auditEntries).toHaveLength(1);
 335:         
 336:         const ignoredData = JSON.parse(auditEntries[0].new_values);
 337:         expect(ignoredData.asset_ids).toContain(asset1);
 338:         expect(ignoredData.asset_ids).toContain(asset2);
 339:       });
 340:     });
 341:   });
 342: 
 343:   describe('API Integration Tests', () => {
 344:     describe('GET /api/duplicates', () => {
 345:       it('should return duplicate groups for authenticated users', async () => {
 346:         // Create test duplicates
 347:         const asset1 = await createTestAsset({
 348:           class: 'watch',
 349:           name: 'Test Watch',
 350:           book_value_jpy: 100000,
 351:           liquidity_tier: 'L3'
 352:         });
 353: 
 354:         const asset2 = await createTestAsset({
 355:           class: 'watch',
 356:           name: 'Test Watch',
 357:           book_value_jpy: 110000,
 358:           liquidity_tier: 'L3'
 359:         });
 360: 
 361:         const response = await request(app)
 362:           .get('/api/duplicates')
 363:           .set('Cookie', authCookie)
 364:           .expect(200);
 365: 
 366:         expect(Array.isArray(response.body.duplicate_groups)).toBe(true);
 367:         expect(typeof response.body.total_groups).toBe('number');
 368:         expect(typeof response.body.total_assets).toBe('number');
 369:       });
 370: 
 371:       it('should require authentication', async () => {
 372:         await request(app)
 373:           .get('/api/duplicates')
 374:           .expect(401);
 375:       });
 376:     });
 377: 
 378:     describe('POST /api/duplicates/merge', () => {
 379:       it('should merge duplicate assets successfully', async () => {
 380:         const asset1 = await createTestAsset({
 381:           class: 'watch',
 382:           name: 'Merge Test',
 383:           book_value_jpy: 100000,
 384:           liquidity_tier: 'L3'
 385:         });
 386: 
 387:         const asset2 = await createTestAsset({
 388:           class: 'watch',
 389:           name: 'Merge Test',
 390:           book_value_jpy: 110000,
 391:           liquidity_tier: 'L3'
 392:         });
 393: 
 394:         const response = await request(app)
 395:           .post('/api/duplicates/merge')
 396:           .set('Cookie', authCookie)
 397:           .send({
 398:             asset_ids: [asset1, asset2],
 399:             keep_asset_id: asset1
 400:           })
 401:           .expect(200);
 402: 
 403:         expect(response.body.success).toBe(true);
 404:         expect(response.body.kept_asset_id).toBe(asset1);
 405:         expect(response.body.merged_asset_ids).toContain(asset2);
 406:       });
 407: 
 408:       it('should require admin role', async () => {
 409:         // This would require setting up a viewer user and testing with their session
 410:         // For now, we test the basic validation
 411:         await request(app)
 412:           .post('/api/duplicates/merge')
 413:           .send({
 414:             asset_ids: [1, 2],
 415:             keep_asset_id: 1
 416:           })
 417:           .expect(401);
 418:       });
 419:     });
 420:   });
 421: 
 422:   // Helper functions
 423:   async function createTestAsset(assetData) {
 424:     return new Promise((resolve, reject) => {
 425:       const stmt = db.prepare(`
 426:         INSERT INTO assets (class, name, note, book_value_jpy, liquidity_tier, valuation_source)
 427:         VALUES (?, ?, ?, ?, ?, ?)
 428:       `);
 429:       
 430:       stmt.run(
 431:         assetData.class,
 432:         assetData.name,
 433:         assetData.note || '',
 434:         assetData.book_value_jpy,
 435:         assetData.liquidity_tier,
 436:         assetData.valuation_source || 'manual',
 437:         function(err) {
 438:           if (err) reject(err);
 439:           else resolve(this.lastID);
 440:         }
 441:       );
 442:       stmt.finalize();
 443:     });
 444:   }
 445: 
 446:   async function createStockDetails(assetId, stockData) {
 447:     return new Promise((resolve, reject) => {
 448:       const stmt = db.prepare(`
 449:         INSERT INTO us_stocks (asset_id, ticker, exchange, quantity, avg_price_usd)
 450:         VALUES (?, ?, ?, ?, ?)
 451:       `);
 452:       
 453:       stmt.run(
 454:         assetId,
 455:         stockData.ticker,
 456:         stockData.exchange,
 457:         stockData.quantity,
 458:         stockData.avg_price_usd,
 459:         (err) => {
 460:           if (err) reject(err);
 461:           else resolve();
 462:         }
 463:       );
 464:       stmt.finalize();
 465:     });
 466:   }
 467: 
 468:   async function createPreciousMetalDetails(assetId, metalData) {
 469:     return new Promise((resolve, reject) => {
 470:       const stmt = db.prepare(`
 471:         INSERT INTO precious_metals (asset_id, metal, weight_g, purity, unit_price_jpy)
 472:         VALUES (?, ?, ?, ?, ?)
 473:       `);
 474:       
 475:       stmt.run(
 476:         assetId,
 477:         metalData.metal,
 478:         metalData.weight_g,
 479:         metalData.purity,
 480:         metalData.unit_price_jpy,
 481:         (err) => {
 482:           if (err) reject(err);
 483:           else resolve();
 484:         }
 485:       );
 486:       stmt.finalize();
 487:     });
 488:   }
 489: 
 490:   async function getAssetById(id) {
 491:     return new Promise((resolve, reject) => {
 492:       db.get('SELECT * FROM assets WHERE id = ?', [id], (err, row) => {
 493:         if (err) reject(err);
 494:         else resolve(row || null);
 495:       });
 496:     });
 497:   }
 498: 
 499:   async function getAuditLogEntries(action) {
 500:     return new Promise((resolve, reject) => {
 501:       db.all('SELECT * FROM audit_log WHERE action = ? ORDER BY created_at DESC', [action], (err, rows) => {
 502:         if (err) reject(err);
 503:         else resolve(rows || []);
 504:       });
 505:     });
 506:   }
 507: });

