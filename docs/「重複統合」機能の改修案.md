# 「重複統合」機能の改修案（レビュー反映・CSV未採用）

本書は、手動の「重複統合」ページを廃止し、新規登録フローに自動統合を内包する方針のレビュー結果を反映した最終案です。CSV導入は採用しません。

## 1. 背景と目的
- 目的: 新規登録時に同一銘柄かつ同一口座の既存ポジションへ自動統合し、手動統合UIを廃止する。
- 対象: `us_stock`（米国株）、`jp_stock`（日本株）。その他クラスは対象外。

## 2. レビュー結果サマリ
- 自動統合に一本化: 重複統合専用ページは廃止。登録フローに統合ロジックを組み込み。
- 統合キー: 「クラス + 識別子 + 口座ID」一致で統合。
  - 識別子: USは`ticker`、JPは`code`。
  - 口座: 別口座（特定/一般/NISA）や別ブローカーは統合しない。
- 平均取得単価: 加重平均で更新（USはUSD、JPはJPY）。
- 簿価JPY: 原則ロット簿価合計。取得時為替が不明なUSは暫定的に比例スケールも許容。
- 監査ログ: 統合前後差分と計算方式（unit/scale）を必ず記録。
- 既存の重複検出サービス: 画面は廃止、ロジックは例外対応用として維持可能。

## 3. 確認事項と決定
- 口座粒度: 証券会社＋口座種（特定/一般/NISA）で識別。NISAの区分（成長/つみたて/旧など）は実装しない。
- 統合条件: 「クラス + 識別子（US:ticker / JP:code）+ account_id」完全一致のみ統合。
- US簿価JPY: 取得時為替があればロット簿価加算、なければ比例スケールで更新（将来lot化で置換）。
- UI: 新規登録フォームに口座選択（新規作成可）と統合プレビュー（dry_run）を追加。
- エラー方針: 数量>0、平均単価>0必須。識別子・口座必須。通貨整合をクラス別に検証。

## 4. 設計詳細

### 4.1 ドメインモデル（追加/変更）
- accounts
  - id, broker, account_type（特定/一般/NISA）, name（任意表示名）, created_at, updated_at
- us_stocks（変更）
  - account_id（FK相当）を追加。論理一意: `UNIQUE(ticker, account_id)`。
- jp_stocks（変更）
  - account_id（FK相当）を追加。論理一意: `UNIQUE(code, account_id)`。

### 4.2 API（管理系）
- POST `/admin/assets`
  - 共通: `class`, `name`, `note`, `acquired_at`, `liquidity_tier`, `tags`, `account_id` もしくは `account`（新規作成用）
  - us_stock: `ticker`, `exchange`, `quantity`, `avg_price_usd`, `fx_at_acq`（任意, USDJPY）
  - jp_stock: `code`, `quantity`, `avg_price_jpy`
  - オプション: `merge_policy`（`auto_weighted_avg` 固定）
  - 挙動: 統合キー一致で統合、未一致で新規作成。
  - レスポンス例:
    - `merged: true/false, kept_asset_id, before: {qty, avg}, after: {qty, avg}, audit_id`

### 4.3 UI/UX
- 新規登録フォームに「口座選択」「口座を新規作成」モーダルを追加。
- 入力後に「プレビューを表示」→ 統合プレビュー（数量/平均/簿価の変化、方式unit/scale）を確認してから登録。

### 4.4 監査ログ
- action: `AUTO_MERGE_STOCK`
- old_values/new_values に数量・平均単価・簿価の差分、入力パラメータ（account_id, fx_at_acq等）、計算方式（unit/scale）を保存。

## 5. マイグレーション手順とDDL（SQLite）

```sql
BEGIN TRANSACTION;

-- 5.1 accounts テーブル新設
CREATE TABLE IF NOT EXISTS accounts (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  broker TEXT NOT NULL,
  account_type TEXT NOT NULL,      -- tokutei / ippan / nisa
  name TEXT,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 5.2 既存 us_stocks / jp_stocks に account_id 追加
ALTER TABLE us_stocks ADD COLUMN account_id INTEGER;  -- NULL許容で追加
ALTER TABLE jp_stocks ADD COLUMN account_id INTEGER;  -- NULL許容で追加

-- 5.3 既存レコードの仮付与（Default Account を1件作成）
INSERT INTO accounts (broker, account_type, name)
VALUES ('default', 'tokutei', 'Default Account');
UPDATE us_stocks SET account_id = (SELECT id FROM accounts WHERE broker='default' LIMIT 1)
 WHERE account_id IS NULL;
UPDATE jp_stocks SET account_id = (SELECT id FROM accounts WHERE broker='default' LIMIT 1)
 WHERE account_id IS NULL;

-- 5.4 論理一意（インデックス）
CREATE UNIQUE INDEX IF NOT EXISTS idx_us_unique_ticker_account
  ON us_stocks (UPPER(TRIM(ticker)), account_id);
CREATE UNIQUE INDEX IF NOT EXISTS idx_jp_unique_code_account
  ON jp_stocks (UPPER(TRIM(code)), account_id);

COMMIT;
```

注意: 既存テーブルに対するFK追加はSQLiteでは難しいため、当面はアプリ側バリデーションで担保し、将来テーブル再作成時に物理FKを導入します。

## 6. 計算ユニット（設計）

### 6.1 統合アルゴリズム（共通）
- 入力: 既存（old_qty, old_avg, old_book_jpy）、追加（add_qty, add_avg, fx_at_acq[USのみ任意]）。
- 前提: add_qty > 0, add_avg > 0。
- 数量: `new_qty = old_qty + add_qty`。
- 平均取得単価（加重平均）:
  - US: `new_avg_usd = (old_avg_usd*old_qty + add_avg_usd*add_qty) / new_qty`。
  - JP: `new_avg_jpy = (old_avg_jpy*old_qty + add_avg_jpy*add_qty) / new_qty`。
- 簿価JPY:
  - unit法（推奨）: `new_book_jpy = old_book_jpy + floor2(add_qty * add_avg_native * fx_at_acq)`。
  - scale法（fx_at_acq不明時の暫定）: `unit_book = old_book_jpy / old_qty`、`new_book_jpy = floor2(unit_book * new_qty)`。
- 監査: before/after と採用方式（unit/scale）を記録。

### 6.2 擬似コード（JS）

```js
function floor2(x) { return Math.floor(x * 100) / 100; }

function mergeUsPosition({ oldQty, oldAvgUsd, oldBookJpy, addQty, addAvgUsd, fxAtAcq }) {
  if (!(addQty > 0) || !(addAvgUsd > 0)) throw new Error('invalid_input');
  const newQty = oldQty + addQty;
  const newAvgUsd = (oldAvgUsd * oldQty + addAvgUsd * addQty) / newQty;

  let method = 'unit';
  let newBookJpy;
  if (Number.isFinite(fxAtAcq) && fxAtAcq > 0) {
    newBookJpy = Math.floor((oldBookJpy + floor2(addQty * addAvgUsd * fxAtAcq)));
  } else {
    method = 'scale';
    const unitBook = oldQty > 0 ? oldBookJpy / oldQty : 0;
    newBookJpy = Math.floor(floor2(unitBook * newQty));
  }
  return { newQty, newAvgUsd, newBookJpy, method };
}

function mergeJpPosition({ oldQty, oldAvgJpy, oldBookJpy, addQty, addAvgJpy }) {
  if (!(addQty > 0) || !(addAvgJpy > 0)) throw new Error('invalid_input');
  const newQty = oldQty + addQty;
  const newAvgJpy = (oldAvgJpy * oldQty + addAvgJpy * addQty) / newQty;
  const newBookJpy = Math.floor(floor2(oldBookJpy + addAvgJpy * addQty));
  return { newQty, newAvgJpy, newBookJpy, method: 'unit' };
}
```

### 6.3 トランザクション適用順序
- BEGIN → 既存取得 → 統合計算 → `assets.book_value_jpy` 更新 → クラス別テーブル更新 → `audit_log` 記録 → COMMIT

## 7. バリデーションとエッジケース
- 数量/平均取得単価は正の数。USは小数株可、JPは整数推奨。
- 通貨整合: USはUSD単価、JPはJPY単価のみ。
- 異口座種別（特定/一般/NISA）や異ブローカーでは統合しない。
- 識別子正規化: `UPPER(TRIM(...))` を適用（重複防止インデックスと一致）。
- 同時投入の競合は一意インデックス＋アプリ側リトライで解消。

## 8. テスト観点
- 統合なし（新規）/統合あり（連続統合、端数株、極端価格差）。
- US/JPのunit/scale 両方式。監査ログの差分整合。

## 9. ロールアウト
- 先にDDL適用し、既存データへ `account_id` をバックフィル。
- UIとAPIを段階的に切替（フォーム導線更新、旧統合UIは非表示）。
- 稼働初期は整合性チェックを継続（ダッシュボード警告など）。

## 10. 具体例（リクエスト/レスポンスと計算）

### 10.1 US株（fxあり → unit法）
- before: oldQty=10, oldAvgUsd=100.00, oldBookJpy=150,000
- add:    addQty=5,  addAvgUsd=120.00, fxAtAcq=155.00（USDJPY）
- 計算: newQty=15 / newAvgUsd=106.6667... / add簿価JPY=93,000 / newBookJpy=243,000

リクエスト例:

```json
POST /admin/assets
{
  "class": "us_stock",
  "name": "Apple Inc.",
  "account_id": 1,
  "ticker": "AAPL",
  "exchange": "NASDAQ",
  "quantity": 5,
  "avg_price_usd": 120.0,
  "fx_at_acq": 155.0,
  "merge_policy": "auto_weighted_avg"
}
```

レスポンス例:

```json
{
  "merged": true,
  "kept_asset_id": 42,
  "before": { "qty": 10, "avg_usd": 100.0, "book_jpy": 150000 },
  "after":  { "qty": 15, "avg_usd": 106.6667, "book_jpy": 243000 },
  "method": "unit",
  "audit_id": 9876
}
```

### 10.2 US株（fxなし → scale法）
- before: oldQty=10, oldAvgUsd=100.00, oldBookJpy=150,000
- add:    addQty=5,  addAvgUsd=120.00, fxAtAcq=未入力
- 計算: newQty=15 / newAvgUsd=106.6667... / unit_book=15,000 / newBookJpy=225,000

レスポンス例:

```json
{
  "merged": true,
  "kept_asset_id": 42,
  "before": { "qty": 10, "avg_usd": 100.0, "book_jpy": 150000 },
  "after":  { "qty": 15, "avg_usd": 106.6667, "book_jpy": 225000 },
  "method": "scale",
  "audit_id": 9877
}
```

### 10.3 JP株（加重平均＋ロット簿価）
- before: oldQty=100, oldAvgJpy=2,000.00, oldBookJpy=200,000
- add:    addQty=50,  addAvgJpy=2,200.00
- 計算: newQty=150 / newAvgJpy=2,066.6667... / newBookJpy=310,000

リクエスト例:

```json
POST /admin/assets
{
  "class": "jp_stock",
  "name": "トヨタ自動車",
  "account_id": 1,
  "code": "7203",
  "quantity": 50,
  "avg_price_jpy": 2200.0,
  "merge_policy": "auto_weighted_avg"
}
```

レスポンス例:

```json
{
  "merged": true,
  "kept_asset_id": 51,
  "before": { "qty": 100, "avg_jpy": 2000.0, "book_jpy": 200000 },
  "after":  { "qty": 150, "avg_jpy": 2066.6667, "book_jpy": 310000 },
  "method": "unit",
  "audit_id": 9880
}
```

### 10.4 異なる口座IDは統合しない
- 例: account_id=1 にAAPL保有があっても、account_id=2 のAAPLは別ポジションとして新規作成。

レスポンス例:

```json
{
  "merged": false,
  "created_asset_id": 73
}
```

### 10.5 監査ログ 記録例

```json
{
  "table_name": "assets",
  "record_id": 42,
  "action": "AUTO_MERGE_STOCK",
  "old_values": { "qty": 10, "avg_usd": 100.0, "book_jpy": 150000 },
  "new_values": { "qty": 15, "avg_usd": 106.6667, "book_jpy": 243000, "account_id": 1, "ticker": "AAPL" },
  "user_id": "admin",
  "source": "api"
}
```

## 11. UIワイヤー（フォーム/モーダル例・運用向け文言）

### 11.1 新規登録フォーム（共通レイアウト）
```
[新規登録 - 株式]
クラス: (us_stock | jp_stock)  ▼
口座:  [Account Picker ▼]  [口座を新規作成]
名称:  [................................]
取得日: [yyyy-mm-dd]   メモ: [..............................]

-- us_stock 選択時 --
ティッカー: [AAPL]      取引所: [NASDAQ ▼]
数量:       [  5.0 ]    平均取得単価(USD): [120.00]
取得時為替 USD/JPY(任意): [155.00]

-- jp_stock 選択時 --
銘柄コード: [7203]
数量:       [  50 ]     平均取得単価(JPY): [2200.00]

[プレビューを表示]   [登録する]
```

- 入力バリデーション:
  - 数量: 正の数（USは小数株可、JPは整数推奨）。
  - 平均取得単価: 正の数（USはUSD、JPはJPY）。
  - 取得時為替: US株のみ任意。入力があればunit法、無ければscale法。
  - 口座は必須。クラス別に必須/任意の切替を行う。

### 11.2 統合プレビュー（確認モーダル）
```
[統合プレビュー]
対象: us_stock / AAPL / 口座ID:1
統合方式: unit（取得時為替を使用）

数量      :   10  →  15
平均単価  : USD 100.00  →  USD 106.6667
簿価(円)  : 150,000     →  243,000

[キャンセル]   [この内容で統合する]
```

- 備考:
  - プレビューは `dry_run: true` で算出（保存しない）。
  - 統合対象が無い場合は「新規作成内容の確認」として差分を省略表示。

### 11.3 口座新規作成（モーダル）
```
[口座を新規作成]
証券会社: [SBI証券 ▼]
口座種別: (特定 | 一般 | NISA)
表示名  : [My NISA]

[保存する]
```

- バリデーション:
  - 証券会社/口座種別は必須。
  - 表示名は任意（省略時は自動生成: 例「SBI証券/特定」）。

### 11.4 エラーステート表示
- フィールド下にインラインエラー（例: 「数量は正の数で入力してください」）。
- 送信時にトーストで概要（最初のエラーへスクロール）。
- サーバーエラーはトースト＋詳細（`need_unit_price` 等は日本語に変換して表示）。

### 11.5 キーボード/アクセシビリティ
- Tab順の保証、`aria-describedby` でエラー紐づけ。
- モーダルは `Esc` で閉じる、[この内容で統合する] は `Enter`、[キャンセル] は `Alt+C`（例）。
- ボタンは `disabled` と `aria-disabled` を併用。

### 11.6 フロー概要
- フローA（統合あり）: 入力 → プレビュー → 統合プレビュー → この内容で統合する → 成功トースト
- フローB（統合なし）: 入力 → プレビュー（新規要約） → 登録する → 成功トースト
- フローC（口座作成）: 口座を新規作成 → 保存する → Pickerに反映 → 入力続行

### 11.7 フィールド→API マッピング（抜粋）
- us_stock: ティッカー→`ticker`、取引所→`exchange`、数量→`quantity`、平均取得(USD)→`avg_price_usd`、取得時為替→`fx_at_acq`、口座→`account_id`
- jp_stock: 銘柄コード→`code`、数量→`quantity`、平均取得(JPY)→`avg_price_jpy`、口座→`account_id`
- プレビュー: `dry_run: true` で差分試算（`merged`, `before/after`, `method`）。

## 12. 運用注意（既存DBの編集について）
- 既存データ編集時は「新フォーマットへの整合」を必ず満たすこと。
  - us_stocks/jp_stocks には必ず `account_id` を設定。
  - USは `ticker`、JPは `code` を正規化（大文字化＋前後空白除去）。
  - 数量・平均取得単価は正の数（USはUSD、JPはJPY）。
  - `assets.book_value_jpy` とクラス別テーブルの内容が矛盾しないよう同時更新（UIからの編集を推奨）。
  - 重複しない一意性: USは(UPPER(TRIM(ticker)), account_id)、JPは(UPPER(TRIM(code)), account_id) が一意。
  - 監査性確保: 可能な限りアプリのAPI/UI経由で変更し、`audit_log` に記録（直接DB更新は非推奨）。
- 推奨手順:
  1) UIの[編集]から数量・平均単価を修正 → 2) [プレビューを表示]で差分確認 → 3) [登録する]で反映（監査ログ自動記録）。
- 注意: CSVは未採用。外部で編集したCSVを直接取り込む運用は行わない。

以上。

## 13. 管理画面エラーメッセージ一覧（日本語）

- 必須項目: 入力必須です。
- class_required: クラスを選択してください。
- account_required: 口座を選択してください。
- ticker_required: ティッカーを入力してください。
- code_required: 銘柄コードを入力してください。
- quantity_invalid: 数量は正の数で入力してください（USは小数可、JPは整数推奨）。
- avg_price_invalid_usd: 平均取得単価(USD)は正の数で入力してください。
- avg_price_invalid_jpy: 平均取得単価(JPY)は正の数で入力してください。
- fx_rate_invalid: 取得時為替(USD/JPY)は正の数で入力してください。
- dry_run_failed: 統合プレビューを取得できませんでした。時間をおいて再試行してください。
- merge_conflict: 同一口座に同一銘柄が同時に登録されました。もう一度プレビュー後に実行してください。
- need_unit_price: 単価情報が不足しています。平均取得単価または取得時為替を入力してください。
- market_disabled: マーケットデータ取得は無効です（設定で有効化してください）。
- upstream_unavailable: 相場データの取得に失敗しました。時間をおいて再試行してください。
- auth_required: ログインが必要です。
- admin_required: 管理者権限が必要です。
- not_found: 対象の資産が見つかりません。
- unsupported_asset_class: この資産クラスは対応していません。
- us_stock_data_not_found: 米国株データが見つかりません。
- jp_stock_data_not_found: 日本株データが見つかりません。
- precious_metal_data_not_found: 貴金属データが見つかりません。
- valid_avg_price_usd_required: 有効な平均取得単価(USD)を入力してください。
- valid_avg_price_jpy_required: 有効な平均取得単価(JPY)を入力してください。
- db_error: 内部エラーが発生しました。管理者にお問い合わせください。
