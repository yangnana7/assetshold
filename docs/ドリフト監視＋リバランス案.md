“ドリフト監視＋リバランス案”

# ① DBマイグレーション（目標配分＆許容帯）

`migrations/20250813_rebalance.sql` を新規作成

```sql
CREATE TABLE IF NOT EXISTS target_allocations(
  class TEXT PRIMARY KEY,
  target_pct REAL NOT NULL CHECK(target_pct >= 0)
);
CREATE TABLE IF NOT EXISTS settings(
  key TEXT PRIMARY KEY,
  value TEXT NOT NULL
);
-- 既定: 許容 ±5%
INSERT OR IGNORE INTO settings(key, value) VALUES ('tolerance_pct', '5');
```

> 適用方法（あなたの環境に合わせて）
> 既に導入したマイグレーションランナーがあればそれで実行。なければ一度だけSQLiteで流せばOK。

---

# ② サーバ：サービス & API

## 2-1) サービスロジック（集計・計算）

`server/rebalance/service.js`（新規）

```js
const sqlite3 = require('sqlite3').verbose();

const DEFAULT_CLASSES = ['us_stock','jp_stock','precious_metal','watch','collection','real_estate','cash'];

function dbAll(db, sql, params=[]) { return new Promise((ok, ng)=> db.all(sql, params, (e, rows)=> e?ng(e):ok(rows))); }
function dbGet(db, sql, params=[]) { return new Promise((ok, ng)=> db.get(sql, params, (e, row)=> e?ng(e):ok(row))); }
function dbRun(db, sql, params=[]) { return new Promise((ok, ng)=> db.run(sql, params, function(e){ e?ng(e):ok(this)})); }

async function getTolerancePct(db) {
  const row = await dbGet(db, `SELECT value FROM settings WHERE key='tolerance_pct'`);
  const v = row ? Number(row.value) : 5;
  return Number.isFinite(v) ? v : 5;
}
async function setTolerancePct(db, v) {
  await dbRun(db, `INSERT INTO settings(key,value) VALUES('tolerance_pct',?) ON CONFLICT(key) DO UPDATE SET value=excluded.value`, [String(v)]);
}

async function getTargets(db) {
  return await dbAll(db, `SELECT class, target_pct as pct FROM target_allocations ORDER BY class`);
}
async function setTargets(db, targets) {
  const seen = new Set();
  await dbRun(db, 'BEGIN IMMEDIATE');
  try {
    for (const t of targets) {
      if (!t.class || !Number.isFinite(Number(t.pct))) throw new Error('bad target row');
      if (seen.has(t.class)) throw new Error('duplicate class');
      seen.add(t.class);
      await dbRun(db, `
        INSERT INTO target_allocations(class,target_pct)
        VALUES(?,?)
        ON CONFLICT(class) DO UPDATE SET target_pct=excluded.target_pct
      `, [String(t.class), Number(t.pct)]);
    }
    await dbRun(db, 'COMMIT');
  } catch (e) {
    await dbRun(db, 'ROLLBACK'); throw e;
  }
}

async function getLatestValuationOrBook(db, assetId, bookValue, useBookIfMissing=true) {
  const row = await dbGet(db, `
    SELECT value_jpy FROM valuations
     WHERE asset_id = ? ORDER BY as_of DESC, id DESC LIMIT 1
  `, [assetId]);
  if (row && Number.isFinite(Number(row.value_jpy))) return Number(row.value_jpy);
  return useBookIfMissing ? Number(bookValue||0) : 0;
}
function liquidityScore(liq) { const m = {L1:1,L2:2,L3:3,L4:4}; return m[liq] || 99; }
function roundJPY(n){ return Math.round(n); }

async function getCurrentByClass(db, useBookIfMissing=true) {
  const assets = await dbAll(db, `SELECT id, class, name, book_value_jpy, liquidity_tier FROM assets`);
  const byClass = {}; const assetValues = [];
  for (const a of assets) {
    const val = await getLatestValuationOrBook(db, a.id, a.book_value_jpy, useBookIfMissing);
    assetValues.push({ asset_id:a.id, class:a.class, name:a.name, liquidity_tier:a.liquidity_tier, value_jpy:val, book_value_jpy:a.book_value_jpy });
    byClass[a.class] = (byClass[a.class]||0) + val;
  }
  const total = Object.values(byClass).reduce((s,v)=>s+v,0);
  const pct = {}; for (const c of Object.keys(byClass)) pct[c] = total>0 ? (byClass[c]/total*100) : 0;
  return { total, byClass, pct, assetValues };
}

function computePlanFromTargets(current, targets, tolerancePct, to='target', minTrade=0) {
  const classes = Array.from(new Set([...DEFAULT_CLASSES, ...Object.keys(current.byClass), ...targets.map(t=>t.class)]));
  const tgtMap = {}; for (const t of targets) tgtMap[t.class] = Number(t.pct);
  for (const c of classes) if (!(c in tgtMap)) tgtMap[c] = 0;
  const tgtSum = Object.values(tgtMap).reduce((s,v)=>s+v,0) || 1;
  const norm = 100 / tgtSum; for (const c of classes) tgtMap[c] = tgtMap[c]*norm;

  const rows = [], breaches = [];
  for (const c of classes) {
    const curV = current.byClass[c] || 0;
    const curPct = current.total>0 ? (curV/current.total*100) : 0;
    const tgt = tgtMap[c] || 0;
    const min = Math.max(0, tgt - tolerancePct);
    const max = Math.min(100, tgt + tolerancePct);
    const drift = curPct - tgt;
    const breach = (curPct < min) || (curPct > max);
    if (breach) breaches.push(c);
    rows.push({ class:c, cur_value_jpy:roundJPY(curV), cur_pct:curPct, target_pct:tgt, min_pct:min, max_pct:max, drift_pct:drift, breach });
  }

  // 目標値（to=mid なら許容帯の中央値）
  const desired = {};
  for (const r of rows) {
    if (!r.breach) { desired[r.class] = current.byClass[r.class] || 0; continue; }
    desired[r.class] = current.total * ((to==='mid' ? (r.min_pct+r.max_pct)/2 : r.target_pct)/100);
  }

  // 乖離（+BUY / -SELL）。最小取引額で丸め落とし
  const deltas = {};
  for (const c of classes) {
    const curV = current.byClass[c] || 0;
    const want = desired[c] !== undefined ? desired[c] : curV;
    const d = want - curV;
    deltas[c] = Math.abs(d) < minTrade ? 0 : d;
  }
  const buys = Object.entries(deltas).filter(([,a])=>a>0).map(([c,a])=>({class:c, amount:a}));
  const sells= Object.entries(deltas).filter(([,a])=>a<0).map(([c,a])=>({class:c, amount:Math.abs(a)}));

  // 資産レベル按分（流動性 L1→.. 優先）
  const byClassAssets = {};
  for (const a of current.assetValues) {
    (byClassAssets[a.class] ||= []).push(a);
  }
  for (const c of Object.keys(byClassAssets)) {
    byClassAssets[c].sort((x,y)=> liquidityScore(x.liquidity_tier)-liquidityScore(y.liquidity_tier) || (y.value_jpy - x.value_jpy));
  }

  const trades = [];
  let i=0,j=0;
  while (i<sells.length && j<buys.length) {
    const s = sells[i], b = buys[j];
    const x = Math.min(s.amount, b.amount);
    const sellAssets=[]; let rem=x;
    for (const a of (byClassAssets[s.class]||[])) {
      if (rem<=0) break;
      const can = Math.min(rem, a.value_jpy);
      if (can<=0) continue;
      sellAssets.push({ asset_id:a.asset_id, name:a.name, amount_jpy:roundJPY(can), liquidity_tier:a.liquidity_tier });
      rem -= can;
    }
    const buyAssets=[]; rem=x;
    for (const a of (byClassAssets[b.class]||[])) {
      if (rem<=0) break;
      const can = Math.min(rem, Math.max(0, a.value_jpy*10)); // 買いは仮の上限（調整余地）
      if (can<=0) continue;
      buyAssets.push({ asset_id:a.asset_id, name:a.name, amount_jpy:roundJPY(can), liquidity_tier:a.liquidity_tier });
      rem -= can;
    }
    trades.push({ from_class:s.class, to_class:b.class, amount_jpy:roundJPY(x), sells:sellAssets, buys:buyAssets });
    s.amount -= x; b.amount -= x;
    if (s.amount<=1) i++; if (b.amount<=1) j++;
  }

  const netBuy  = buys.reduce((s,o)=>s+o.amount,0);
  const netSell = sells.reduce((s,o)=>s+o.amount,0);
  return { rows, breaches, deltas, trades, net_flow_jpy: Math.round(netBuy - netSell) };
}

function toCsv(current, plan) {
  const header = ['class','cur_value_jpy','cur_pct','target_pct','min_pct','max_pct','drift_pct','breach'];
  const lines = [header.join(',')];
  for (const r of plan.rows) {
    lines.push([r.class, r.cur_value_jpy, r.cur_pct.toFixed(2), r.target_pct.toFixed(2),
      r.min_pct.toFixed(2), r.max_pct.toFixed(2), r.drift_pct.toFixed(2), r.breach?'1':'0'].join(','));
  }
  return lines.join('\n');
}

module.exports = {
  getTargets, setTargets, getTolerancePct, setTolerancePct,
  getCurrentByClass, computePlanFromTargets, toCsv
};
```

## 2-2) API追加（server.js に差し込み）

server.js で **DBパス取得関数**と**エンドポイント**を追加してください。

```diff
+ const path = require('path');
+ const sqlite3 = require('sqlite3').verbose();
+ const {
+   getTargets, setTargets, getTolerancePct, setTolerancePct,
+   getCurrentByClass, computePlanFromTargets, toCsv
+ } = require('./server/rebalance/service');

+ function getDb() {
+   const dbPath = process.env.DB_PATH || path.join(__dirname, 'data', 'portfolio.db');
+   return new sqlite3.Database(dbPath);
+ }

+ // 目標配分の取得
+ app.get('/api/rebalance/targets', async (req, res) => {
+   try {
+     const db = getDb();
+     const [targets, tol] = await Promise.all([getTargets(db), getTolerancePct(db)]);
+     db.close();
+     res.json({ tolerance_pct: tol, targets });
+   } catch (e) { res.status(500).json({ error: String(e.message || e) }); }
+ });

+ // 目標配分の更新
+ app.post('/api/rebalance/targets', async (req, res) => {
+   try {
+     const db = getDb();
+     const { tolerance_pct, targets } = req.body || {};
+     if (tolerance_pct !== undefined) {
+       const v = Number(tolerance_pct);
+       if (!Number.isFinite(v) || v < 0 || v > 50) throw new Error('bad tolerance_pct');
+       await setTolerancePct(db, v);
+     }
+     if (Array.isArray(targets)) {
+       const sum = targets.reduce((s,t)=> s + Number(t.pct||0), 0);
+       if (sum <= 0) throw new Error('targets sum must be > 0');
+       await setTargets(db, targets.map(t=>({class:String(t.class), pct:Number(t.pct)})));
+     }
+     const [ret, tol] = await Promise.all([getTargets(db), getTolerancePct(db)]);
+     db.close();
+     res.json({ ok:true, tolerance_pct: tol, targets: ret });
+   } catch (e) { res.status(400).json({ error: String(e.message || e) }); }
+ });

+ // リバランスプランの算出
+ app.get('/api/rebalance/plan', async (req, res) => {
+   try {
+     const to = (req.query.to === 'mid') ? 'mid' : 'target';
+     const tol = Number(req.query.tol || NaN);
+     const minTrade = Number(req.query.min_trade || 0);
+     const useBook = (String(req.query.use_book||'1') === '1');
+     const db = getDb();
+     const [targets, defaultTol] = await Promise.all([getTargets(db), getTolerancePct(db)]);
+     const tolerancePct = Number.isFinite(tol) ? tol : defaultTol;
+     const current = await getCurrentByClass(db, useBook);
+     const plan = computePlanFromTargets(current, targets, tolerancePct, to, minTrade);
+     db.close();
+     const csv = toCsv(current, plan);
+     res.json({ as_of: new Date().toISOString(), total_jpy: current.total, tolerance_pct: tolerancePct, to, min_trade_jpy: minTrade, use_book: useBook, plan, csv });
+   } catch (e) { res.status(500).json({ error: String(e.message || e) }); }
+ });
```

---

# ③ クライアント（最小UI）

`client/src/pages/Rebalance.jsx`（新規）

```jsx
import React, { useEffect, useState } from 'react';

export default function Rebalance() {
  const [targets, setTargets] = useState({ tolerance_pct: 5, targets: [] });
  const [plan, setPlan] = useState(null);
  const [tol, setTol] = useState(5);
  const [minTrade, setMinTrade] = useState(10000);
  const [to, setTo] = useState('target');
  const [useBook, setUseBook] = useState(true);

  useEffect(()=>{ fetchTargets(); }, []);

  async function fetchTargets() {
    const r = await fetch('/api/rebalance/targets');
    const j = await r.json();
    setTargets(j);
    if (j && typeof j.tolerance_pct === 'number') setTol(j.tolerance_pct);
  }
  async function fetchPlan() {
    const q = new URLSearchParams({
      tol: String(tol), min_trade: String(minTrade), to, use_book: useBook ? '1' : '0'
    }).toString();
    const r = await fetch(`/api/rebalance/plan?${q}`);
    setPlan(await r.json());
  }
  async function saveTargets() {
    const payload = { tolerance_pct: tol, targets: targets.targets };
    await fetch('/api/rebalance/targets', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
    await fetchTargets();
  }

  return (
    <div className="p-4 grid gap-4 md:grid-cols-3 text-sm">
      <div className="md:col-span-2">
        <h2 className="text-lg font-bold mb-2">ドリフト & リバランス案</h2>
        <div className="mb-2">
          <button className="px-3 py-1 rounded bg-blue-600 text-white" onClick={fetchPlan}>プランを計算</button>
        </div>
        {plan && plan.plan && (
          <>
            <div className="overflow-x-auto">
              <table className="min-w-full border border-neutral-700">
                <thead>
                  <tr className="bg-neutral-900">
                    <th className="px-2 py-1 text-left">クラス</th>
                    <th className="px-2 py-1 text-right">現状(円)</th>
                    <th className="px-2 py-1 text-right">現状(%)</th>
                    <th className="px-2 py-1 text-right">目標(%)</th>
                    <th className="px-2 py-1 text-right">許容範囲</th>
                    <th className="px-2 py-1 text-right">ドリフト(%)</th>
                    <th className="px-2 py-1 text-center">逸脱</th>
                  </tr>
                </thead>
                <tbody>
                  {plan.plan.rows.map((r)=> (
                    <tr key={r.class} className="border-t border-neutral-800">
                      <td className="px-2 py-1">{r.class}</td>
                      <td className="px-2 py-1 text-right">{Intl.NumberFormat('ja-JP').format(r.cur_value_jpy)}</td>
                      <td className="px-2 py-1 text-right">{r.cur_pct.toFixed(2)}</td>
                      <td className="px-2 py-1 text-right">{r.target_pct.toFixed(2)}</td>
                      <td className="px-2 py-1 text-right">{r.min_pct.toFixed(1)}–{r.max_pct.toFixed(1)}</td>
                      <td className={`px-2 py-1 text-right ${Math.abs(r.drift_pct)>=0.01?'font-bold':''}`}>{r.drift_pct.toFixed(2)}</td>
                      <td className="px-2 py-1 text-center">{r.breach ? '⚠' : ''}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>

            <div className="mt-4">
              <div className="font-semibold">売買提案</div>
              {plan.plan.trades.length === 0
                ? <div className="opacity-70">逸脱なし / 最小取引額未満のみ</div>
                : plan.plan.trades.map((t, i)=> (
                    <div key={i} className="mt-2 p-2 rounded border border-neutral-700">
                      <div className="flex justify-between">
                        <div>SELL <b>{t.from_class}</b> → BUY <b>{t.to_class}</b></div>
                        <div>{Intl.NumberFormat('ja-JP').format(t.amount_jpy)} 円</div>
                      </div>
                      <div className="grid md:grid-cols-2 gap-2 mt-2">
                        <div>
                          <div className="text-xs opacity-70">売却候補</div>
                          <ul className="list-disc ml-6">
                            {t.sells.map((s, j)=> <li key={j}>{s.name}（{s.liquidity_tier || '-'}）: {Intl.NumberFormat('ja-JP').format(s.amount_jpy)}円</li>)}
                          </ul>
                        </div>
                        <div>
                          <div className="text-xs opacity-70">購入候補</div>
                          <ul className="list-disc ml-6">
                            {t.buys.map((b, j)=> <li key={j}>{b.name}（{b.liquidity_tier || '-'}）: {Intl.NumberFormat('ja-JP').format(b.amount_jpy)}円</li>)}
                          </ul>
                        </div>
                      </div>
                    </div>
                  ))
              }
            </div>
          </>
        )}
      </div>

      <div className="md:col-span-1">
        <h3 className="font-semibold mb-2">パラメータ</h3>
        <div className="space-y-2">
          <label className="block">許容帯(±%)
            <input type="number" className="w-full bg-neutral-900 p-2 rounded" value={tol} onChange={e=>setTol(Number(e.target.value||0))} />
          </label>
          <label className="block">最小取引額(円)
            <input type="number" className="w-full bg-neutral-900 p-2 rounded" value={minTrade} onChange={e=>setMinTrade(Number(e.target.value||0))} />
          </label>
          <label className="block">合わせ方
            <select className="w-full bg-neutral-900 p-2 rounded" value={to} onChange={e=>setTo(e.target.value)}>
              <option value="target">target（目標ど真ん中へ）</option>
              <option value="mid">mid（許容帯の中央値へ）</option>
            </select>
          </label>
          <label className="inline-flex items-center gap-2">
            <input type="checkbox" checked={useBook} onChange={e=>setUseBook(e.target.checked)} /> 評価が無い資産は簿価で代用
          </label>

          <div className="mt-4">
            <div className="text-xs opacity-70 mb-1">目標配分（合計≈100）</div>
            {(targets.targets||[]).map((t, i)=> (
              <div key={i} className="flex gap-2 mb-1">
                <input className="flex-1 bg-neutral-900 p-2 rounded" value={t.class} readOnly />
                <input type="number" className="w-24 bg-neutral-900 p-2 rounded"
                  value={t.pct}
                  onChange={e=>{
                    const v = [...(targets.targets||[])];
                    v[i] = {...v[i], pct: Number(e.target.value||0)};
                    setTargets({...targets, targets:v});
                  }}/>
              </div>
            ))}
            <button className="mt-2 px-3 py-1 rounded bg-green-600 text-white" onClick={saveTargets}>目標保存</button>
          </div>
        </div>
      </div>
    </div>
  );
}
```

`client/src/App.jsx` にルートを追加

```diff
- import { BrowserRouter, Routes, Route } from 'react-router-dom';
+ import { BrowserRouter, Routes, Route, Link } from 'react-router-dom';
+ import Rebalance from './pages/Rebalance';

  return (
    <BrowserRouter>
-     <Routes>
+     <div className="p-2 bg-neutral-950 border-b border-neutral-800">
+       <Link className="mr-3" to="/">Dashboard</Link>
+       <Link to="/rebalance">Rebalance</Link>
+     </div>
+     <Routes>
        <Route path="/" element={<Dashboard />} />
+       <Route path="/rebalance" element={<Rebalance />} />
      </Routes>
    </BrowserRouter>
  );
```

---

## 動作確認の例

```bash
# 1) マイグレーションを適用
node scripts/apply-migrations.js   # 既存のランナーでOK

# 2) サーバ再起動

# 3) 目標配分の登録（例：US40/JP20/PM20/Cash20、許容±5%）
curl -sX POST localhost:3009/api/rebalance/targets -H "Content-Type: application/json" -d '{
  "tolerance_pct": 5,
  "targets": [
    {"class":"us_stock","pct":40},
    {"class":"jp_stock","pct":20},
    {"class":"precious_metal","pct":20},
    {"class":"cash","pct":20}
  ]
}'

# 4) プランを取得（1万円未満は無視、目標に合わせる）
curl -s "localhost:3009/api/rebalance/plan?min_trade=10000&to=target" | jq .
```

---

## 仕様補足（使い勝手の肝）

* **欠損評価の扱い**：`use_book=1` の時は簿価で代用（既定）。評価が多いほど精度↑。
* **合わせ方**：`to=target` だとド真ん中、`to=mid` だと許容帯の中央値（売買を抑えたいとき）。
* **売買候補の選定**：**流動性 L1→L2→L3→L4** の順で資産に按分。L1がなければL2…と落とす。
* **最小取引額**：端数の売買を自然に**間引く**ためのしきい値。口座事情に合わせて調整。
* **CSV**：APIレスポンスに `csv` 文字列も同梱。ワンクリックで記録へ落とせます（エクスポートに連携可能）。

---
