# 0. 先に叩き切るべきブロッカー（PR-0）

**これを最初のPRで一括処理しないと後続が全部ズレる。**

* `valuations` に `unit_price_jpy REAL` を追加。`ORDER BY as_of DESC, id DESC` での直近取得に統一。

  ```sql
  -- migrations/20250814_add_unit_to_valuations.sql
  ALTER TABLE valuations ADD COLUMN unit_price_jpy REAL;
  CREATE INDEX IF NOT EXISTS idx_valuations_asset_asof ON valuations(asset_id, as_of DESC, id DESC);
  ```
* フロントの `...` 混入を全撤去（`grep -R '\.\.\.' client` →全部修正）。Recharts import を正規形に戻す。
* 認証の危険既定を即廃止：`SESSION_SECRET` を必須ENV、`admin/admin`自動投入禁止、`/api/login` に rate-limit、`helmet` 導入。
* CSVの正本ヘッダをBDD版へ拡張し、日付/数値/列挙の厳格バリデーション（1行エラーでもトランザクション全ロールバック）。

> ここまでが**PR-0**。以降のPR-1/2でご要望機能を差し込む。

---

# 1. 実装①：ダッシュボード「カテゴリー別：簿価総額 vs 時価総額」比較

## 1.1 DB集計レイヤ（Server）

**目的**：アセットクラスごとに「簿価合計」と「時価合計（最新評価があればそれ、無ければ簿価）」を同時に返す。

* 新規SQLビュー（任意）または直書きクエリを追加：

```sql
-- （ビューにするなら）
CREATE VIEW IF NOT EXISTS v_class_totals AS
SELECT
  a.class AS class,
  SUM(a.book_value_jpy) AS book_total_jpy,
  SUM(
    COALESCE(
      (SELECT v.value_jpy
         FROM valuations v
        WHERE v.asset_id = a.id
        ORDER BY v.as_of DESC, v.id DESC
        LIMIT 1),
      a.book_value_jpy
    )
  ) AS market_total_jpy,
  COUNT(*) AS count_assets
FROM assets a
GROUP BY a.class;
```

* API：`GET /api/dashboard/class-summary`

  * 応答例：

    ```json
    {
      "as_of": "2025-08-14T11:00:00Z",
      "items": [
        {"class":"us_stock","book_total_jpy":3338442,"market_total_jpy":3523552,"count":8},
        {"class":"jp_stock","book_total_jpy":4712875,"market_total_jpy":5980000,"count":9},
        {"class":"precious_metal","book_total_jpy":5474068,"market_total_jpy":5500702,"count":8},
        ...
      ]
    }
    ```
  * 実装メモ：

    * `SELECT * FROM v_class_totals` or 上記式そのまま。
    * 速度対策：`assets.class` にインデックス、`idx_valuations_asset_asof` は前節で作成済み。
    * 「純時価」と「簿価」は**小数2桁丸め**→整数円表示はフロント（追記BDD規約）。

## 1.2 UI（Client / Dashboard）

* 「アセット配分ドーナツ」に加え、**横並び棒**（簿価 vs 時価）を**アセットクラス別**で描画。

  * `Recharts <ResponsiveContainer><BarChart>`、`dataKey="book_total_jpy"` と `dataKey="market_total_jpy"` の2系列。
  * 系列ラベル：`簿価` / `時価`。ツールチップで数値フォーマット（Intl ja-JP）。
* テーブル併記：

  * 列：`クラス / 点数 / 簿価合計 / 時価合計 / 乖離(時価-簿価) / 乖離率(%)`。
* ステータス・バッジ：

  * 右上に `市場データ: 有効/無効`（`/api/market/status`）＋ `最終更新JST`。`stale` が混じるなら黄色表示。

> CSSは既定の**多層カード**方針（右カラム右寄せ、評価最大、次に簿価、最後に損益）へ合わせる。棒グラフは**暗色テーマ**前提、凡例は上部。

---

# 2. 実装②：編集UI—株の「株数」と貴金属の「グラム数」を編集可能にし、簿価/時価を更新

## 2.1 モデルと整合ルール

* US株 / JP株

  * `us_stocks(asset_id, ticker, exchange, quantity INTEGER, avg_price_usd REAL)`
  * `jp_stocks(asset_id, code, quantity INTEGER, avg_price_jpy REAL)`
  * **quantity** は **正の整数**（ゼロ不可）。
* 貴金属

  * `precious_metals(asset_id, metal, weight_g REAL, purity REAL)`
  * **weight\_g** は **正の実数**（小数1桁で表示、内部はDOUBLEOK）。

**簿価の更新規約（簡潔かつ堅牢）**
編集により数量/重量が変化したら、簿価は次の優先順で再計算する：

1. **単価情報があれば**：

   * US株：`book_value_jpy = floor2( avg_price_usd * quantity * acquisition_fx_usdjpy )`
   * JP株：`book_value_jpy = floor2( avg_price_jpy * quantity )`
   * 貴金属：`book_value_jpy = floor2( unit_book_cost_jpy_per_gram * weight_g )`（無ければ後述2）
     ※ `acquisition_fx_usdjpy` がモデルに無い現状では、**暫定として(2)を用いる**。必要なら将来 `assets.tags.acq_fx` に保存。

2. **単価が無い場合**は「比例（スケーリング）」：

   * `unit_book = old_book_value_jpy / old_quantity_or_weight`
   * `new_book = floor2( unit_book * new_quantity_or_weight )`
   * `old_quantity_or_weight == 0` のときは**必ずエラー**（単価根拠が無い）。UI側で**単価フィールド入力を要求**。

> `floor2(x) = floor(x*100)/100` → 保存時は整数円丸め。誤差は監査ログで把握。

**時価の更新規約**

* 編集コミット後に `valuations` を**任意で即時更新**できるオプションを提供（デフォルトON）。

  * US株：`price_usd * quantity * USDJPY`
  * JP株：`price_jpy * quantity`
  * 貴金属：**市場時価がある場合のみ**（田中スポット or キャッシュ）。無ければスキップ。
* `MARKET_ENABLE!=1` なら**時価更新はスキップ**（あるいはキャッシュがあれば `stale=true` で採用）。

## 2.2 API

### 2.2.1 共通PATCH（推奨：一発で完結）

`PATCH /api/assets/:id`

* リクエスト（例：US株）：

  ```json
  {
    "class": "us_stock",
    "quantity": 42,
    "avg_price_usd": 191.15,               // 任意
    "recalc": "auto|scale|unit",           // 省略時 auto（1→2 優先）
    "refresh_market": true                 // 省略時 true
  }
  ```
* リクエスト（例：貴金属）：

  ```json
  {
    "class": "precious_metal",
    "weight_g": 150.5,
    "unit_book_cost_jpy_per_gram": 17350,  // 任意。あれば unit 方式。
    "recalc": "auto",
    "refresh_market": true
  }
  ```
* バリデーション：

  * `class` は既存実体と一致必須。
  * 数量/重量の**非負・>0**。US/JP株の数量は整数のみ。
* トランザクション手順：

  1. `SELECT ... FOR UPDATE` 相当（SQLiteなので**IMMEDIATE**トランザクション開始）。
  2. 現行数量/重量・簿価を取得。
  3. サブテーブル（`us_stocks` / `jp_stocks` / `precious_metals`）を更新。
  4. `book_value_jpy` を上記規約で再計算し `assets` を更新。
  5. `refresh_market` が truthy のとき、クラス別ロジックで `valuations` に追記（プロバイダ＆キャッシュ規約順守）。失敗時は**簿価の更新のみコミット**し、時価は**スキップ**（UIへ`stale`/`skipped`）。
  6. `audit_log` に `old→new` をJSON差分で保存（誰が、いつ、どの資産、何を、どのロジックで）。
* レスポンス：

  ```json
  {
    "ok": true,
    "asset": { "id":123, "book_value_jpy": 1234567, ... },
    "valuation": { "value_jpy": 1456789, "stale": false, "as_of":"..." }  // 取得できた場合のみ
  }
  ```

> **代替案（分離API）**：`PATCH /api/us_stocks/:assetId` / `PATCH /api/precious_metals/:assetId` でもよいが、フロントの実装量が増える。今回は**共通PATCH**推し。

## 2.3 フロント（資産一覧の行内編集）

* 行クリック→右ペインのエディタ（カード）に切替（**多層カード**の右カラムを編集モードに）。
* フィールド出し分け：

  * US/JP株：`quantity`（number, step=1, min=1）＋（任意で）`avg_price_*` も入力可。
  * 貴金属：`weight_g`（number, step=0.1, min=0.1）＋（任意で）`unit_book_cost_jpy_per_gram`。
* **プレビュー**（入力中に即時計算）：

  * `new_book` と `delta_book` を表示。
  * 市場更新ONなら、**見込み時価**も（キャッシュ価格があるなら）プレビュー。
* バリデーションと警告：

  * スケール方式で `old_qty==0` / `old_weight==0` なら**赤帯**で「単価が必要」→保存不可。
  * US株で `MARKET_ENABLE=0` のとき、**時価は更新されない**旨の灰色バッジ。
* 保存後：

  * 行の右カラム（財務サマリ）を即リフレッシュ（簿価→太字、損益→色分け、時価→バッジ）。

---

# 3. サービス分割 & 責務整理（リファクタリング）

**目的**：数量/重量変更→簿価再計算→（任意）時価更新、を**可読・再利用**できる形に。

* `server/services/` 配下を導入：

  * `services/bookval.ts`：簿価再計算（auto/scale/unit の戦略クラス or 単関数）
  * `services/market.ts`：価格/為替の取得（既存 `MARKET_ENABLE` ゲート、`price_cache`、TTL、stale 管理）
  * `services/valuations.ts`：クラス別の時価算出（株・貴金属）、`valuations` への書き込み
* `routes/assets.ts`：`PATCH /api/assets/:id` をここに集約。トランザクション境界を**この層で管理**。
* `db/`：簡易DAO（`getAssetWithClassRow(id)` / `updateUsStock(...)` / `updatePreciousMetal(...)` など）。

> **テスト容易性**が激増する。`bookval` と `valuations` は**単体テスト**で叩く。

---

# 4. BDD / 受け入れシナリオ（追加分）

### 4.1 ダッシュボード集計

* **Given** 各クラスに複数資産（評価の有無は混在）
* **When** `GET /api/dashboard/class-summary` を叩く
* **Then** 各クラスに `book_total_jpy` と `market_total_jpy` が返る（評価が無い資産は簿価で代替）
* **And** UIの棒グラフは「簿価」「時価」の2系列が正しく対応する（合計も一致）

### 4.2 株の株数編集（簿価スケール）

* **Given** US株 `quantity=30`, `assets.book_value_jpy=500,000`（評価あり）
* **When** `PATCH /api/assets/:id { class:'us_stock', quantity: 45 }`
* **Then** 簿価は `500,000 * (45/30) = 750,000`（floor2→整数）で更新
* **And** `valuations` も `quantity=45` を用いて再計算され記録（`MARKET_ENABLE=1` かつキャッシュ有効時）

### 4.3 株の株数編集（unit 方式）

* **Given** US株 `quantity=30`, `avg_price_usd=191.15`
* **When** `PATCH ... { quantity:36, avg_price_usd:191.15, recalc:'unit' }`
* **Then** `book = floor2(191.15 * 36 * USDJPY_acq)`（`acq`無ければ scale へのフォールバック or エラー）

### 4.4 貴金属の重量編集（unit 方式）

* **Given** 金 `weight_g=120.0`, `book=2,070,049` → unit ≈ `17,250.41`/g
* **When** `PATCH ... { weight_g: 150.5 }`（recalc\:auto → unit推定）
* **Then** `book ≈ floor2(17,250.41 * 150.5)` に更新
* **And** 田中スポットがキャッシュにあれば `valuations` 更新、無ければ `skipped`

### 4.5 ガード

* **When** `quantity<=0` or `weight_g<=0`
* **Then** `400 bad_request`（メッセージ: 非正の数量/重量は不可）
* **When** scale 必要だが `old_qty==0`
* **Then** `400 need_unit_price`（UIに単価入力を要求）

---

# 5. 最小コード断片（Claudeがそのまま実装できる粒度）

## 5.1 ルート（抜粋 / Node-Express）

```ts
// routes/assets.ts
router.patch('/api/assets/:id', async (req, res) => {
  const id = Number(req.params.id);
  const { class: klass, quantity, avg_price_usd, avg_price_jpy,
          weight_g, unit_book_cost_jpy_per_gram,
          recalc = 'auto', refresh_market = true } = req.body || {};

  const db = getDb(); await dbRun(db, 'BEGIN IMMEDIATE');
  try {
    const asset = await dao.getAssetWithClassRow(db, id); // { asset, classRow }
    if (!asset) throw bad('not_found');
    if (asset.class !== klass) throw bad('class_mismatch');

    // 1) クラス別属性更新
    if (klass === 'us_stock') {
      if (!Number.isInteger(quantity) || quantity <= 0) throw bad('bad_quantity');
      await dao.updateUsStock(db, id, { quantity, avg_price_usd });
    } else if (klass === 'jp_stock') {
      if (!Number.isInteger(quantity) || quantity <= 0) throw bad('bad_quantity');
      await dao.updateJpStock(db, id, { quantity, avg_price_jpy });
    } else if (klass === 'precious_metal') {
      const w = Number(weight_g);
      if (!(w > 0)) throw bad('bad_weight_g');
      await dao.updatePreciousMetal(db, id, { weight_g: w });
    } else {
      throw bad('unsupported_class');
    }

    // 2) 簿価再計算
    const newBook = await bookval.recalcBookValue(db, id, { klass, recalc,
      avg_price_usd, avg_price_jpy, unit_book_cost_jpy_per_gram });

    await dao.updateAssetBook(db, id, newBook);

    // 3) 任意：時価更新
    let val = null;
    if (refresh_market) {
      try { val = await valuations.refreshLatestForAsset(db, id, { klass }); }
      catch (e) { /* swallow; keep book only */ }
    }

    await dbRun(db, 'COMMIT');
    res.json({ ok:true, asset:{ id, book_value_jpy:newBook }, valuation: val });
  } catch (e) {
    await dbRun(db, 'ROLLBACK'); res.status(400).json({ error: String(e.message||e) });
  } finally { db.close(); }
});
```

## 5.2 簿価再計算（抜粋）

```ts
// services/bookval.ts
export async function recalcBookValue(db, assetId, opt) {
  const a = await dao.getAssetWithClassRow(db, assetId); // {asset, classRow}
  const { klass, recalc, avg_price_usd, avg_price_jpy, unit_book_cost_jpy_per_gram } = opt;

  const floor2 = (x:number)=> Math.floor(x*100)/100;

  if (klass === 'us_stock') {
    const qty = a.classRow.quantity;
    if (recalc === 'unit' || (recalc === 'auto' && Number.isFinite(avg_price_usd))) {
      // 取得時FXが無い現状は scale へフォールバック（または opt.acq_fx を使う）
    }
    // scale
    const oldQty = a.prevClassRow.quantity; // 取得しておく
    if (!oldQty) throw new Error('need_unit_price');
    const unitBook = Number(a.asset.book_value_jpy) / oldQty;
    return Math.round(floor2(unitBook * qty));
  }

  if (klass === 'jp_stock') { /* 同様 */ }

  if (klass === 'precious_metal') {
    const w = a.classRow.weight_g;
    if (recalc === 'unit' || (recalc === 'auto' && Number.isFinite(unit_book_cost_jpy_per_gram))) {
      const u = Number(unit_book_cost_jpy_per_gram);
      if (!(u>0)) throw new Error('bad_unit');
      return Math.round(floor2(u * w));
    }
    const oldW = a.prevClassRow.weight_g;
    if (!oldW) throw new Error('need_unit_price');
    const unitBook = Number(a.asset.book_value_jpy) / oldW;
    return Math.round(floor2(unitBook * w));
  }

  throw new Error('unsupported_class');
}
```

---

# 6. テスト計画（最小だが外さない）

* **ユニット**（Vitest）

  * `bookval.recalcBookValue`：US/JP/PM 各ケース（auto/scale/unit、ゼロ割エラー、丸め規約）。
  * `valuations.refreshLatestForAsset`：`MARKET_ENABLE=0/1`、キャッシュ命中、`stale`。
* **API**（Supertest）

  * `PATCH /api/assets/:id`：正常系（簿価更新/評価更新）、ガード（数量0/重量0/クラス不一致）。
  * `GET /api/dashboard/class-summary`：合計整合性、評価無し→簿価代替。
* **E2E**（Playwright）

  * ダッシュボード棒グラフの2系列が描画される（凡例クリックでトグル可）。
  * 行内編集 → 保存 → 右カラムの簿価・損益が即反映。`stale` 時は黄色バッジ。

---

# 7. PR分割（推奨順）

1. **PR-0**：マイグレーション・ビルド修復・セキュリティ初期化・CSVバリデーション
2. **PR-1**：ダッシュボード `class-summary` API ＋ 棒グラフ＆表
3. **PR-2**：`PATCH /api/assets/:id` 実装（数量/重量編集→簿価再計算→任意で評価更新）、行内編集UI
4. **PR-3（任意）**：単価ベース（unit）計算の本格化：US株に `acq_fx` を導入、PMに `unit_book_cost_jpy_per_gram` 永続

---

# 8. 補遺：UXルール（最小にして効く）

* **空の括弧は出さない**（Top3/一覧とも）。
* 数字は**常にIntl ja-JP**で整形。
* 「市場データ」無効時の**説明ツールチップ**を常設。
* 編集カードには**プレビュー**（新簿価・新時価・差額）を必須。

---
